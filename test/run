#!/usr/bin/python3

import contextlib
import glob
import json
import os
import subprocess
import sys
import tempfile
import time
import urllib.request


from typing import Dict, Any

TEST_DIR = os.path.dirname(__file__)


@contextlib.contextmanager
def osbuild_test_store():
    store = os.getenv("OSBUILD_TEST_STORE")
    if store:
        yield store
    else:
        with tempfile.TemporaryDirectory(dir="/var/tmp", prefix="osbuild-composer-test-") as store:
            yield store


@contextlib.contextmanager
def temporary_json_file(obj):
    f = tempfile.NamedTemporaryFile("w", delete=False)
    json.dump(obj, f, indent=2)
    f.close()
    try:
        yield f.name
    finally:
        os.unlink(f.name)


@contextlib.contextmanager
def temporary_ssh_keypair():
    #with tempfile.TemporaryDirectory() as dir:
    with temporary_directory_without_cleanup() as dir:
        #subprocess.run(["ssh-keygen", "-b", "2048", "-t", "rsa", "-f", f"{dir}/id_rsa", "-q", "-N", ""])
        with open("test/keyring/id_rsa", "r") as fd:
            private_key = fd.readlines()
        with open(f"{dir}/id_rsa", "w") as fd:
            fd.writelines(private_key)
        os.chmod(f"{dir}/id_rsa", 0o600)
        with open("test/keyring/id_rsa.pub", "r") as fd:
            private_key = fd.readlines()
        with open(f"{dir}/id_rsa.pub", "w") as fd:
            fd.writelines(private_key)
        try:
            yield dir
        finally:
            pass


@contextlib.contextmanager
def temporary_directory_without_cleanup():
    dir = tempfile.mkdtemp()
    try:
        yield dir
    finally:
        pass


@contextlib.contextmanager
def qemu_boot_image(image_file):
    # run in background
    cmd = ["qemu-system-x86_64",
           "-m", "2048",
           "-snapshot",
           "-accel", "accel=kvm:hvf:tcg",
           "-net", "nic,model=rtl8139", "-net", "user,hostfwd=tcp::1022-:22",
           "-nographic",
           image_file
           ]
    print(f"command: {' '.join(cmd)}")
    vm = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    try:
        yield None
    finally:
        #print("STDOUT")
        #print(str(vm.stdout))
        #print("STDERR")
        #print(str(vm.stderr))
        vm.kill()


def run_osbuild(pipeline, store):
    osbuild_cmd = ["python3", "-m", "osbuild", "--json", "--libdir", ".", "--store", store, "-"]

    build_pipeline = os.getenv("OSBUILD_TEST_BUILD_PIPELINE", None)
    if build_pipeline:
        osbuild_cmd.append("--build-pipeline")
        osbuild_cmd.append(os.path.abspath(build_pipeline))

    result = dict()
    try:
        result = json.loads(subprocess.check_output(osbuild_cmd, cwd="./osbuild", encoding="utf-8", input=json.dumps(pipeline)))
    except subprocess.CalledProcessError as err:
        print(err.output)

    return result["tree_id"], result["output_id"]


def run_test(case, store):
    if "pipeline" in case:
        _, output_id = run_osbuild(case["pipeline"], store)
        filename = os.path.join(store, "refs", output_id, case["compose"]["filename"])
    else:
        filename, _ = urllib.request.urlretrieve(case["url"])

    info = json.loads(subprocess.check_output(["tools/image-info", filename]))
    if info != case["expected"]:
        with temporary_json_file(case["expected"]) as a, temporary_json_file(info) as b:
            subprocess.run(["diff", "--unified", "--color", "--label", "expected", a, "--label", "got", b], check=False)
        return False

    return True


def public_key_to_string(public_key_file) -> str:
    with open(public_key_file) as pk_file:
        ssh_key_content = str(pk_file.read())

    return ssh_key_content.strip()


def qcow2_image_blueprint(public_key_file):
    blueprint = {
        "name": "qcow2-boot-test",
        "description": "Image for boot test",
        "packages": [],
        "modules": [],
        "groups": [],
        "customizations": {
            "user": [
                {
                    "name": "redhat",
                    "password": "$y$j9T$hMKTMCO/s27TcOMRH9eUN1$6G0Jrc20QiptW6P3fwm3LKDd/4IIVSr1N2u611UwNgB",
                    "groups": ["wheel"]
                }
            ],
            "sshkey": [
                {
                    "user": "redhat",
                    "key": public_key_to_string(public_key_file)
                }
            ],
            "services": {
                "enabled": ["sshd"]
            }
        }
    }
    return blueprint


def generate_blueprint(temporary_directory: str, image_type: str, public_key_file: str) -> str:
    dispatcher = {
        "qcow2": qcow2_image_blueprint
    }
    blueprint_dict = dispatcher[image_type](public_key_file)
    blueprint_fname = f"{temporary_directory}/blueprint-{image_type}.json"
    with open(blueprint_fname, "w") as blueprint_fd:
        blueprint_fd.write(json.dumps(blueprint_dict))

    return blueprint_fname


def generate_pipeline(temporary_directory: str, image_type: str, blueprint_fname: str) -> (str, Dict[Any, Any]):
    # res = subprocess.run(["./osbuild-pipeline", "-output-format", image_type, "-blueprint", blueprint_fname],
    #                      stdout=subprocess.PIPE,
    #                      check=True)
    #
    # pipeline_string = res.stdout.decode("utf-8")
    # pipeline_dict = json.loads(pipeline_string)
    # pipeline_fname = f"{temporary_directory}/pipeline-{image_type}.json"
    # with open(pipeline_fname, "w") as pipeline:
    #     pipeline.write(pipeline_string)
    with open("test/cases/qcow2_local_boot.json", "r") as fd:
        test_case_dict = json.load(fd)

    pipeline_dict = test_case_dict["pipeline"]
    pipeline_string = json.dumps(pipeline_dict)
    pipeline_fname = f"{temporary_directory}/pipeline-{image_type}.json"
    with open(pipeline_fname, "w") as pipeline:
        pipeline.write(pipeline_string)

    return pipeline_fname, pipeline_dict


def run_ssh_test(private_key):
    cmd = ["ssh",
           "-p", "1022",
           "-i", private_key,
           "-o", "StrictHostKeyChecking=no",
           "-v",
           "redhat@localhost",
           "systemctl is-system-running"]
    print(cmd)
    for _ in range(40):
        try:
            print("running ssh with timeout")
            sp = subprocess.run(cmd, timeout=120, check=True, stdout=subprocess.PIPE)
            #stdout = subprocess.check_output(cmd, timeout=20, stderr=subprocess.STDOUT)
            output = sp.stdout.decode('utf-8').strip()
            print(output)
            if output == "running":
                print("success")
                return 0
        except subprocess.TimeoutExpired:
            print("timeout expired")
        except subprocess.CalledProcessError as e:
            print(e)
            time.sleep(20)

    print("failure")
    return 1


def main(args):
    # New part, this should be better organized
    try:
        flag: str = args[0]
        if flag.startswith("--"):
            with osbuild_test_store() as store:
                print("created test store")
                #store = "/var/osbuild"
                with temporary_ssh_keypair() as keydir:
                    print("created ssh key")
                    with temporary_directory_without_cleanup() as tmpdir:
                        print("created tmp dir")
                        bp_fname = generate_blueprint(tmpdir, "qcow2", f"{keydir}/id_rsa.pub")
                        print("bp generated")
                        pl_fname, pl_string = generate_pipeline(tmpdir, "qcow2", bp_fname)
                        print("pl generated")
                        print(pl_fname)
                        print("starting osbuild")
                        _, output_id = run_osbuild(pl_string, store)
                        print("osbuild success")
                        with qemu_boot_image(f"{store}/refs/{output_id}/image.qcow2"):
                            #print("image is booting, you have 5 mins to play around with it")
                            #time.sleep(5*60)
                            ret = run_ssh_test(f"{keydir}/id_rsa")

            return ret
    except IndexError:
        pass

    # Lars's original code, needed for backwards compatibility
    failed = False
    with osbuild_test_store() as store:
        for filename in args or glob.glob(f"{TEST_DIR}/cases/*.json"):
            name = os.path.basename(filename)[:-5]
            with open(filename) as f:
                case = json.load(f)

            print(f"{name}")
            if not run_test(case, store):
                print(f"FAIL")
                print()
                failed = True

    return 1 if failed else 0


r = main(sys.argv[1:])
if r:
    sys.exit(r)
